---
title: AWS Lambda Web Adapterのコードを読む
published_at: 2025-12-16T00:00:00.000Z
tag: AWS, AWS Lambda, Rust
---

# AWS Lambda Web Adapterのコードを読む

## 概要

本稿では、業務で利用することになった[AWS Lambda Web Adapter](https://github.com/awslabs/aws-lambda-web-adapter)（以降、AWS LWA）について、その内部実装をコードから読み解いていきます。
そもそも存在を知らなかった、なんとなく利用したことはあるが内部実装までは把握していなかったという方に向けて、何かしらの一助になれば幸いです。

## AWS LWAの役割

簡潔に表すと、AWS LWAは[AWS LambdaランタイムAPI](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/runtimes-api.html)に準拠したリバースプロキシと言えるでしょう。AWS LWAはLambdaランタイムAPIの`http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next`に対して _GET_ HTTPリクエストをポーリング実行し、返却されたHTTPレスポンスボディに含まれる各種AWSサービスなどのイベントおよびコンテキストをHTTPオブジェクト[^1]に変換し、Lambda関数に対してHTTPリクエストを実行します。Lambda関数はHTTPリクエストを受けてAWS LWAにHTTPレスポンスを返却します。このHTTPレスポンスをAWS LWAが引き継いで、`http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/:AwsRequestId/response`に _POST_ HTTPリクエストを実行します。

この抽象化レイヤーがLambda関数の前段で実行されることにより、ユーザーはコードに大きな変更を加えることなく、Lambda関数としてお好みのWebフレームワークをデプロイおよび実行することが可能になります。

## AWS Lambda拡張（extensions）について

AWS LWAのコードを読む前に、まずは当該リポジトリのコードがAWS Lambdaにおいてどのような役割を担っているのかを把握しておくと全体感が掴みやすくなります。

とはいえ、AWS Lambdaとは、という疑問から全てをさらうには筆者の知識も時間も足りないので、必要なものを掻い摘んで紹介することとします。

最初に、AWS Lambdaには[拡張（extensions）](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-extensions.html)が提供されています。当機能は[2021年頃に一般公開](https://aws.amazon.com/blogs/aws/getting-started-with-using-your-favorite-operational-tools-on-aws-lambda-extensions-are-now-generally-available/)となりました。AWS Lambda拡張には内部拡張と外部拡張の二種類があり、AWS LWAは外部拡張にあたります。外部拡張はLambda関数（function）とは独立したプロセスで実行されるため、Lambda関数を記述するプログラミング言語とは異なるプログラミング言語[^2]で記述することが可能です。

## Lambda実行環境のライフサイクルとAWS Lambda拡張

次に、外部拡張がLambda関数の実行に伴ってどのように関わっていくのかを見ていきます。

Lambda実行環境には`Init`->`Restore`(SnapStart利用時のみ)->`Invoke`->`Shutdown`という大枠の[ライフサイクル](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-runtime-environment.html)があり、`Init`フェーズ中に、`/opt/extensions`ディレクトリ以下に配置された外部拡張を探査します。

また、`Init`フェーズのサブフェーズとして`Extension init`->`Runtime init`->`Function init`のライフサイクルがあり、先ほど探査した外部拡張はこの中の`Extension init`で初期化されます。

`Extension init`フェーズでは、起動した外部拡張が[Lambda拡張API](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/runtimes-extensions-api.html)を通じて、`http://${AWS_LAMBDA_RUNTIME_API}/2020-01-01/extension/register`へ _POST_ HTTPリクエストで外部拡張を登録し、完了次第`http://${AWS_LAMBDA_RUNTIME_API}/2020-01-01/extension/event/next`へ _GET_ HTTPリクエストを実行することで準備が完了したことを伝えます。

最後に、[`Shutdown`フェーズ](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle-shutdown)にて数時間毎に更新および保全のため、Lambda実行環境を終了します。この時、外部拡張に`Shutdown`イベントが送信されます。
何らかの理由により一定時間内に拡張機能自身が正常終了しない場合、[`SIGKILL`シグナルにより外部拡張は終了](https://github.com/aws-samples/graceful-shutdown-with-aws-lambda)します。

## AWS LWAとRust

ここからようやくAWS LWAのソースコードについて触れていくことが出来ます。

まず、AWS LWAのソースコードはRustで記述されています。Rustは今日では[Linuxカーネルで採用](https://rust-for-linux.com)されたり、[Chromium](https://chromium.googlesource.com/chromium/src/+/6e25f74ea8b7f77e6b6645c765444ffa9e7ef19d/docs/rust.md)や[Firefox](https://firefox-source-docs.mozilla.org/build/buildsystem/rust.html)などのWebブラウザーおよびそのプロジェクト、JavaScriptランタイムのDenoや[AWS Lambdaの内部実装](https://github.com/firecracker-microvm/firecracker?tab=readme-ov-file#overview)など幅広い分野で採用されています。

AWS Lambda拡張とRustの親和性という点では、Lambdaは現在[`x86_64`と`arm64`の64ビット命令セットアーキテクチャをサポート](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/foundation-arch.html)しており、Rustのコンパイル対象として[`x86_64-unknown-linux-musl`と`aarch64-unknown-linux-musl`](https://doc.rust-lang.org/beta/rustc/platform-support.html#tier-2-with-host-tools)[^3]の[glibc](https://www.gnu.org/software/libc/)を動的リンクせず、Linuxの標準Cライブラリを静的リンクする[musl](https://musl.libc.org)をサポートしていることが採用に至ったと推測できます。muslをターゲットとしてコンパイルすることで、Lambda実行環境にglibcが存在するかどうかという点に依存せず単体の実行可能バイナリをAWS Lambda拡張として起動できます。

## AWS LWAが利用しているサードパーティーライブラリ

具体的なRustコードを見ていく前に、ワンクッション置いて、AWS LWAがRustの標準ライブラリ（`std`）以外でどのようなサードパーティーライブラリを利用しているかを確認してもよいでしょう。
Rustは今日の他のプログラミング言語と比較すると、標準ライブラリが豊富とは言えない側に当たると言えます。JSONや正規表現のライブラリも`std`には含まれていません。Rustの言語仕様やツールチェーンのCargoなどへの変更プロセスを管理する[Rust RFCs](https://github.com/rust-lang/rfcs)において、[`std`への大きな変更](https://github.com/rust-lang/rfcs/tree/45bfa54b27a0d1e678ce2fcdd782a471f75463a5?tab=readme-ov-file#when-you-need-to-follow-this-process)にはこのプロセスに従う必要があります。また、各RFCの随所[^4]で、`std`に変更および機能追加することにより発生する永続的なメンテナンスコストという点に言及されている様子も伺えます。

そういった点から見ると、Rustで実践的なプログラムを記述する際には得てして各分野におけるデファクトのサードパーティーライブラリが用いられる傾向にあります。

そこで、まずはプログラムの実行中に利用するサードパーティーライブラリの使用を明示する[`Cargo.toml`の`dependencies`](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/Cargo.toml#L19-L47
)を見ていきます。

すると、JSONシリアライザー/デシリアライザーの`serde_json`、非同期ランタイムの`tokio`、`hyper`からHTTPクライアントや[WebブラウザのURL仕様](https://url.spec.whatwg.org/)に準拠した実装の`url`などを利用しているようです。
この辺りは、HTTPサーバーおよびHTTPクライアントのAPIを提供している先ほど登場したJavaScriptランタイムのDenoなどでも見る顔ぶれです。

冒頭でAWS LWAとは何か、という結論で半分以上答えを出してしまった感じはありますが、このようにして主要なサードパーティーライブラリを予め把握しておくことで、改めてAWS LWAが何を処理するのか、というのがこの時点でおおよそ見当ついたのではないでしょうか。

さらに[`Cargo.toml`の`[[bin]]`フィールド](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries)を見ていくと[`src/main.rs`がプログラムのエントリーポイント](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/Cargo.toml#L61)に指定されています。

よって、まずは[`src/main.rs`](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/src/main.rs)から見ていくことにします。

## 非同期ランタイムの採用

プログラムのエントリーポイントである`src/main.rs`の`main`関数の実装は空白行などを除くと10行にも満たない内容です。

まず注目したところは、`main`関数が`#[tokio::main]`という属性が付与された非同期関数という点です。この属性の仕組み自体は[公式ドキュメント](https://tokio.rs/tokio/tutorial/hello-tokio#async-main-function)に委ねることとします。
非同期関数および非同期ランタイムの`tokio`を採用している理由として、[HTTPクライアントの`hyper`が非同期ランタイムを前提としている](https://hyper.rs/guides/1/init/runtime/)こと、および`adapter.run`を辿っていくと依存ライブラリの最深部でイベントループ[^5]が構築されていることにより、少なくともそれが伝播していることによるものと見ることが出来ます。
Lambdaは通常、[一つのリクエストに対して都度Lambda実行環境を作成する](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-concurrency.html)ため、Lambda実行環境ごとに作成されるAWS LWAが複数のIOを同時に処理することはありません。

よって、AWS LWAの処理だけを見ると、特別に非同期ランタイムを利用してIOをブロックしない[^6]ようにする必要性があまり見えてこないようにも思えます。

さて、ここで`main`関数に戻り、[`adapter.register_default_extension`](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/src/main.rs#L20-L21)の実装を辿っていくと、`tokio`で[`task`](https://tokio.rs/tokio/tutorial/spawning#tasks)を起動し、その内部でLambda拡張APIを通じて、[一連の外部拡張登録工程を実施](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/src/lib.rs#L219-L248)しています。

さらによく見ていくと、`"events": []`という空配列のリクエストボディが指定されている様子が伺えます。なぜ空配列なのかを追求してみると、どうやら明確に[`Invoke`および`Shutdown`のイベントを登録](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/runtimes-extensions-api.html#extensions-registration-api-a)して実施したい処理があるわけではないので、[このような実装になっているという経緯](https://github.com/awslabs/aws-lambda-web-adapter/pull/120#discussion_r1064067282)のようです。

これを踏まえてもう一度`main`関数に戻ると、`adapter.register_default_extension`は非同期でLambda拡張APIを通じてAWS LWAを外部拡張として登録工程を実施するが、その完了を待たずに[Lambda関数のヘルスチェック](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/src/main.rs#L22-L23)およびイベントのポーリングに移行するというコードになっているという事情が見えてきます。あくまで推測にはなりますが、外部拡張の登録工程IOの[レイテンシー](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-extensions.html#using-extensions-reg)を避ける狙いがあるのかもしれません。

実際、AWS LWAをコンテナイメージ内に含めてWebアプリケーションをデプロイした場合、CloudWatchには以下のような順序でログが出ていました。

```bash
2025-11-18T07:59:15.801Z
Listening on http://0.0.0.0:8000/ (http://localhost:8000/)
2025-11-18T07:59:15.813Z
EXTENSION Name: lambda-adapter State: Ready Events: []
2025-11-18T07:59:15.814Z
START RequestId: REQUEST_ID Version: $LATEST
```

この時はコールドスタートが無く、先にWebアプリケーションの起動して、その後AWS LWAの登録が完了し、瞬く間にリクエストを迎えているように見えます。

また、先ほど出てきた依存ライブラリがホストされている[aws-lambda-rust-runtime](https://github.com/aws/aws-lambda-rust-runtime)[^7]リポジトリは、`lambda_runtime`を始めとするAWS LWAも利用するライブラリを提供しています。これらはAWS LWA向けに特化したものではなく、様々なユースケースに対応出来るよう汎用的な構成になっています。
ユーザー定義のLambda関数で他のAWSサービスなどに対する様々なIOが発生し得ることを踏まえると、非同期ランタイムを基盤とする[^8]のは納得のいく選択です。

さらに、つい先日[Lambdaマネージドインスタンスが発表](https://aws.amazon.com/jp/blogs/news/introducing-aws-lambda-managed-instances-serverless-simplicity-with-ec2-flexibility/)されました。[Lambdaマネージドインスタンスは一つのLambda実行環境で複数のリクエストを処理](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-managed-instances-execution-environment.html)することが可能です。
これまでのLambdaの前提と打って変わって、Lambdaマネージドインスタンスを利用する場合はAWS LWAがまさに非同期ランタイムを基盤として複数のIOを同時に処理する場面が出てきたと言えます。

## レスポンスボディの圧縮

AWS LWAに環境変数の`AWS_LWA_ENABLE_COMPRESSION`を`true`に設定すると[`CompressionLayer::new`](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/src/lib.rs#L321)が呼び出され、レスポンスボディの圧縮が有効になります。
圧縮の判断基準などは、[ドキュメントに記載](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/README.md#L130-L131)もありますが、実装は[`tower-http`ライブラリ側に存在](https://github.com/tower-rs/tower-http/blob/33166c8104be9b40ec15c480503d50d8c2312062/tower-http/src/compression/predicate.rs#L121-L130)しています。

## まとめ

AWS LWAは高いパフォーマンスを実現し、Lambda実行環境に配置するために最適な実行可能バイナリを生成するためにプログラミング言語のRustを採用したと想像できます。
また、早くからRustの非同期ランタイムである`tokio`を基盤として開発されており、一つのLambda実行環境で複数のリクエストを処理できるLambdaマネージドインスタンスの登場したことなども加味すると、現時点でかなり完成度が高いように見えます。

## 終わりに

実際にAWS LWAリポジトリのコードを読んでみるまでは、漠然とイベントか何かがHTTPリクエストに変換されているのだろうぐらいの想像をしていました。コード行数もさして多くないしそんなに難しくないだろうとたかを括ったところ、コードそのものよりそもそものAWS Lambdaの仕組みに対する理解が浅いということを痛感し、改めてその仕組みやアーキテクチャを把握するところからの始まりでした。AWS Lambda自体はマネージド部分が多いですが、今回の調査をきっかけにその裏側に対する解像度が少しばかり高まったような感触もあります。今後はAWS LWAと同じくRustで記述されている[Firecracker](https://firecracker-microvm.github.io)およびLinuxの Kernel-based Virtual Machine (KVM)などについても自身で掘り下げていくことが出来れば、よりサービスの裏側を想像しやすくなるのではないかと考えています。


[^1]: [lambda-httpの概要](https://github.com/aws/aws-lambda-rust-runtime/tree/c9f487f296432e46a4d7af24923cfd6dd7cafe2c/lambda-http)より抜粋しました。
[^2]: AWS Lambdaは、[OSのみのランタイム上で特定のプログラミング言語を事前コンパイルした実行可能バイナリを利用](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/runtimes-provided.html)できます。
[^3]: [Rustのコンパイル](https://blog.rust-jp.rs/tatsuya6502/posts/2019-12-statically-linked-binary/)に関してはこちらがより詳しいです。
[^4]: [`std`](https://github.com/rust-lang/rfcs/blob/45bfa54b27a0d1e678ce2fcdd782a471f75463a5/libs_changes.md#is-an-rfc-required)への変更方針、[`assert_ne`](https://github.com/rust-lang/rfcs/blob/45bfa54b27a0d1e678ce2fcdd782a471f75463a5/text/1653-assert_ne.md#drawbacks)マクロ、[`Pin`](https://github.com/rust-lang/rfcs/blob/45bfa54b27a0d1e678ce2fcdd782a471f75463a5/text/2349-pin.md#drawbacks)構造体、[`Vec`構造体および`String`構造体の`splice`](https://github.com/rust-lang/rfcs/blob/45bfa54b27a0d1e678ce2fcdd782a471f75463a5/text/1432-replace-slice.md#drawbacks)メソッドなど。
[^5]: [`lambda_web_adapter::run`](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/src/main.rs#L25) -> [`lambda_http::run`](https://github.com/awslabs/aws-lambda-web-adapter/blob/cf6875cb1401f6a2adcabf8874d2bf20e02ff3c9/src/lib.rs#L309-L332) -> [`lambda_runtime::run`](https://github.com/aws/aws-lambda-rust-runtime/blob/c9f487f296432e46a4d7af24923cfd6dd7cafe2c/lambda-http/src/lib.rs#L196-L204) -> [`Runtime::run`](https://github.com/aws/aws-lambda-rust-runtime/blob/c9f487f296432e46a4d7af24923cfd6dd7cafe2c/lambda-runtime/src/lib.rs#L113-L127) -> [`Runtime::run_with_incoming`](https://github.com/aws/aws-lambda-rust-runtime/blob/c9f487f296432e46a4d7af24923cfd6dd7cafe2c/lambda-runtime/src/runtime.rs#L140-L188)
[^6]: `tokio`は[IOバウンドなアプリケーション](https://tokio.rs/tokio/tutorial#when-not-to-use-tokio)に適しています。
[^7]: [aws-lambda-rust-runtimeのコード詳細についてはこちら](https://zenn.dev/taiki45/articles/aws-lambda-with-go-and-rust)がより詳しいです。
[^8]: [aws-lambda-rust-runtimeリポジトリの初期のコミット](https://github.com/aws/aws-lambda-rust-runtime/commit/43a0cb6815ef66a290fd977b7941fac7ac8d6ccf)を見ると、最初から`tokio`が採用されています。当該コミットが2018年で[Rustの`async`キーワードが安定化されたのが2019年頃](https://blog.rust-lang.org/2019/11/07/Async-await-stable/)であり、まだまだ非同期Rustのエコシステムが確立されているとは言えない時代であったと想像できます。